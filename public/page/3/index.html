
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Literate Programming</title>
  <meta name="author" content="Steve Klabnik">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  

  <link rel="canonical" href="http://blog.steveklabnik.com/page/3/index.html"/>
  <link href="/favicon.png" rel="shortcut icon" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://s3.amazonaws.com/ender-js/jeesh.min.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="http://feeds.feedburner.com/steveklabnik" rel="alternate" title="Literate Programming" type="application/atom+xml"/>
  <!--Fonts from Google's Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>

</head>

<body  >
  <header><hgroup>
  <h1><a href="/">Literate Programming</a></h1>
  
    <h2>Code is data, data is code. s/data/language/g;</h2>
  
</hgroup>

</header>
  <nav role=navigation><ul role=subscription data-subscription="rss">
  <li><a href="http://feeds.feedburner.com/steveklabnik" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<form action="http://google.com/search" method="get">
  <fieldset role="site-search">
    <input type="hidden" name="q" value="site:blog.steveklabnik.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
<ul role=main-navigation>
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">



  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2011/01/02/goals-for-2011.html">Goals for 2011</a></h1>
    
    
      <p class="meta">





  



<time datetime="2011-01-02T00:00:00-08:00" pubdate  data-updated="true" >Jan 2<span>nd</span>, 2011</time></p>
    
  </header>


  <div class="entry-content"><p>This year I&#8217;m happy to report that I have much more upbeat plans than last
year&#8217;s kind of sad post. With that said, here&#8217;s my 2011 goals:</p>

<ul>
<li><p>I want to work for other people 2 days per week on average for the year.</p></li>
<li><p>I want to write something every day</p></li>
<li><p>I want to keep building on the initial success that Hackety Hack&#8217;s 1.0 launch
has brought. I&#8217;d like to get a new release out every month or so, with a 2.0 for
Christmas 2011.</p></li>
<li><p>I want to start exercising again. My current lifestyle is still too sedentary
for my liking.</p></li>
<li><p>I want to eat better.</p></li>
<li><p>I want to start logging my activities every day.</p></li>
</ul>


<p>Most of these are kinda standard. I used to go to the gym all the time, but
I&#8217;ve never eaten healthily. Both of these things are going to become more
important as I age, however, and so I&#8217;m starting to actually give them serious
consideration.</p>

<p>Hackety Hack had an impressive 1.0 launch, but I have lots of work to do.
Please check out the <a href="http://blog.hackety-hack.com/">Hackety Hack blog</a> tomorrow for a report on that.
Basically, I now have a sizable userbase to attend to, and they&#8217;ve found a
bunch of bugs that I need to iron out before starting to build more stuff.</p>

<p>The logging is an idea that I got from <a href="http://www.sebastianmarshall.com/">Sebastian Marshall</a>. We&#8217;ve had some
good conversation recently, and we talked briefly about the importance of
measuring things. You can only improve things if you know what&#8217;s actually
wrong&#8230; I&#8217;m going to be tracking the time that I do various activities, and
seeing if I can improve. If I feel this is working, I&#8217;ll write about it in a
month or so.</p>

<p>I&#8217;ve already made some progress on all of these, actually. Obviously, most of
them can only truly be realized in a year&#8217;s time, but here&#8217;s what I&#8217;ve got
going:</p>

<ul>
<li><p>I&#8217;ve got my logging set up going. I&#8217;m trying to figure out how to make it as
unobtrusive as possible, but I think I have a good first run at it.</p></li>
<li><p>I&#8217;ve got a set up for the work situation, and if all goes well, that should
be accomplished. I originally thought I&#8217;d have to front-load a bit, but it
seems like I&#8217;ll be doing this most of the year.</p></li>
<li><p>Working that little will enable me to really accomplish my Hackety goals.</p></li>
<li><p>Now that Maria is graduated, she&#8217;s got some time to cook things, and she&#8217;s
also interested in eating better, and her habits are better than mine already.
Hopefully this will lead to success.</p></li>
<li><p>Logging should help keep my eyes on the prize for my exercise and writing goals.</p></li>
</ul>


<p>So, that&#8217;s it! Good luck with your goals in the new year!</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/12/25/hackety-hack-v1-0.html">Hackety Hack v1.0</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-12-25T00:00:00-08:00" pubdate  data-updated="true" >Dec 25<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>It&#8217;s been a long journey. I have a lot to say about this, but it&#8217;ll have to
wait until I&#8217;m not in the middle of nowhere spending some time with Maria&#8217;s
family. I just wanted to tell you all Merry Christmas, and point you at the
<a href="http://blog.hackety-hack.com/post/2457961910/merry-christmas-and-a-1-0-announcement">Hackety Hack v1.0 release announcement</a> and the new
<a href="http://hackety-hack.com/">Hackety Hack website</a>.</p>

<p>Merry Christmas!</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/11/17/the-hardest-decision-i-ve-ever-made.html">The Hardest Decision I&#8217;ve Ever Made.</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-11-17T00:00:00-08:00" pubdate  data-updated="true" >Nov 17<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>I&#8217;ll cut to the chase: I&#8217;ve stepped down as CTO of CloudFab. I don&#8217;t
want to discuss details, but life is too short to not be doing what
you want with it. And, after a period of careful thought and
consideration, it&#8217;s no longer the right thing for me. It was an
amicable parting, and my replacements are already in place, and doing
cool things. I&#8217;m happy with what I&#8217;ve accomplished, but it&#8217;s time  for me to
move on.</p>

<p>This raises the question: what am I moving on to? Here&#8217;s the answer:
Hackety Hack. What I truly care about is teaching, writing, and
discussing software. If I could do anything, I&#8217;d hack on Hackety,
share what I know with others, and keep learning and playing with new
things all day long.</p>

<p>However, there&#8217;s a certain question of sustainability here: I&#8217;m not
made of money, and I have lots of bills to pay. However, doing the
&#8216;obvious&#8217; thing would be really, truly wrong: Hackety Hack is not and
will never be a startup. It&#8217;s a social venture, if anything: it would
be absolutely unquestioningly wrong for me to ever ask anyone for a
single cent for it. It&#8217;d also be counterproductive: how could I share
programming with everyone if I excluded those without disposable
income?</p>

<p>So to this end, Hackety cannot be all that I do. And while I really
want to teach, I also have a lot to learn. Luckily, I have some great
allies in this area: I&#8217;ve been working alongside two teachers at the
University of Pittsburgh over the past month or so: one in the English
department, and one in the Computer Science department. In doing so,
I&#8217;ve come to realize that my place in life is actually in the middle:
while I love the theoretical side of CS, I&#8217;m actually much more
interested in the application. And teachers need to be effective
communicators, so investing in writing is absolutely worthwhile for
me. At the same time, I&#8217;ve really enjoyed every chance I&#8217;ve had to
write: there&#8217;s a reason I keep three blogs now! I&#8217;m also incredibly
interested in the parallels that exist between computer and human
languages. I like the comparison between refactoring and composition.
I think the two fields have a lot to learn from one another. It&#8217;s
something I&#8217;d like to explore more.</p>

<p>To do so, I&#8217;ll have to finish off my undergrad degree. Luckily, I&#8217;m
very close, so I&#8217;ll be doing that in the spring. Afterward, it&#8217;s my
intention to go to grad school in the English department, so I&#8217;m
furiously working on my application, with the help of the
aforementioned teacher. At the same time, I&#8217;ll possibly help teach or
TA classes in the CS department as well. I&#8217;m hoping to combine my
solid foundations in the hard sciences with the new perspective and
improved analysis that the humanities can offer.</p>

<p>I don&#8217;t think that academia is where I want to stay forever, but I
think it&#8217;s a good place for me to grow for now. It&#8217;s time for me to
invest in myself a little. I think I&#8217;ll end up a much better person in
the end.</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/09/24/trolling-is-a-art.html">Trolling Is a Art</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-09-24T00:00:00-07:00" pubdate  data-updated="true" >Sep 24<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>I find it incredibly hard not to be judgmental.</p>

<p>I&#8217;m not sure what part of my personality makes this happen, but even
when I try to curb tearing down other people, I end up doing it
anyway. I&#8217;m not sure if it&#8217;s just me, but I think part of the problem
is that these kinds of things are rewarded.</p>

<p><img src="/images/stevesajerk.png" alt="" /></p>

<p>This is me, being a jerk.</p>

<p>One of the reasons that I use my real name everywhere is to try to
improve the civility of my discourse. When you&#8217;re anonymous, it&#8217;s
really easy to be callous. And when I used a handle, I was even worse.
But even now, I can think of three times when I accidentally was mean
for basically no reason: That tweet, the Diaspora incident, and the
only Hacker News comment I&#8217;ve ever deleted.</p>

<p>In all three of these instances, it&#8217;s not so much that I was wrong.
It&#8217;s that I ended up presenting my criticisms poorly. I think I did a
decent job with the Diaspora one, but people still took it the wrong
way, so I failed to communicate. I&#8217;m certainly not infallible. I
guarantee you there are n00b errors and security holes in my own
codebases. So I really shouldn&#8217;t be so quick to judge.
That&#8217;s all I have to say about that. I&#8217;ll just have to do better going
forward.</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/09/21/80-of-success-is-showing-up.html">80% of Success Is Showing Up</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-09-21T00:00:00-07:00" pubdate  data-updated="true" >Sep 21<span>st</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>It&#8217;s funny how true this quote is.</p>

<p>There are three people that I really admire: <em>why, Zed Shaw, and Yehuda Katz.
And to simplify my tenses a bit, I&#8217;ll speak of </em>why in the present tense. What
do these three guys have in common? They all churn out badass software like
nobody&#8217;s business. _why started so many projects that it just adds to his
mythical qualities; Zed has been cranking out software and blogs left and
right, and Yehuda&#8217;s &#8221;<a href="http://yehudakatz.com/2010/09/14/heres-to-the-next-3-years/">I&#8217;m quitting Engine Yard</a>&#8221; post basically said &#8220;I&#8217;m
pretty much done rebuilding the server side of software in my own image, now
it&#8217;s time for me to focus on the client side of the equation.&#8221; Not with that
much hubris, of course, but it&#8217;s pretty much true.</p>

<p>Now, I don&#8217;t mean to imply that they&#8217;ve &#8216;just shown up,&#8217; but it seems to me
that productivity is directly related to just getting started on things. I&#8217;ve
had people tell me that they think I&#8217;m superhumanly productive, which is funny
to me: I&#8217;m almost constantly fretting about how much time I waste every day.
And while I do have a ton of projects, unlike all those guys, I tend to not
fully finish them. It&#8217;s something that I&#8217;ve been trying to work on lately,
because I have so many things that I want to accomplish.</p>

<p>For me, the biggest hold on cranking out even more stuff is just simply
starting to work. Often, if i slack off for half an hour, I slack off all
evening. Now that there&#8217;s a TV with Netflix in my house again, it&#8217;s difficult
to not watch all of the amazing documentaries that are on there. But if I
manage to start working on stuff, I find that I keep doing it. It&#8217;s like I get
to pick one or the other: projects or slacking. I can&#8217;t quite seem to do both.
And so I&#8217;ve been starting some minor experimentation to see if I can&#8217;t work on
projects more often than not.</p>

<p>One thing that I&#8217;ve sort of half-tried is the <a href="http://en.wikipedia.org/wiki/Pomodoro_Technique">Pomodoro Technique</a>. It&#8217;s
pretty sweet: basically, you set a timer for 25 minutes, and start working.
You can take a break when it goes off. Surely you can wait to refresh Hacker
News for 25 minutes, right? That&#8217;s something else I&#8217;ve done: on Friday, I put
Reddit and HN in my /etc/hosts file. They&#8217;re totally blocked, for now. After
<a href="http://blog.steveklabnik.com/trouble-with-diaspora">last week&#8217;s situation</a>, I spent waaaay too much freaking time on HN, even
for me. I love it, and I&#8217;m learning a ton every day, but it&#8217;s becoming an
issue for my productivity. So it&#8217;s gone for a bit. It&#8217;s been rough, but I&#8217;ve
been getting lots done, and I think when I start reading it again, I&#8217;ll be
able to keep it at reasonable levels.</p>

<p>Anyway, so that&#8217;s what I&#8217;m doing to keep productive. Anyone else have any
thoughts on this? How do you keep working on side projects? What works for
you?</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/09/17/trouble-with-diaspora.html">Trouble With Diaspora</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-09-17T00:00:00-07:00" pubdate  data-updated="true" >Sep 17<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>So, Wednesday, Diaspora was released.</p>

<p>If you&#8217;re not familiar, a few months ago everyone was up in arms about the
latest Facebook privacy change. So four college kids started <a href="http://www.kickstarter.com/projects/196017994/diaspora-the-personally-controlled-do-it-all-distr">a Kickstarter
project</a> with a dream: let&#8217;s make a distributed, private Facebook. They
asked for $10,000. They got about $200,000.</p>

<p>They worked on the code all summer, in secret. Wednesday, a &#8216;developer
preview&#8217; came out. They&#8217;d promised something by the end of the summer, and the
15th of September is the last day. So <a href="http://github.com/diaspora/diaspora">they put it up on GitHub</a>.</p>

<p>Oh boy.</p>

<p>Basically, the code is really, really bad. I don&#8217;t mean to rain on anyone&#8217;s
parade, but <a href="http://www.theregister.co.uk/2010/09/16/diaspora_pre_alpha_landmines/">there are really, really bad security holes</a>. And they&#8217;re
there due to things that any professional programmer would never dream of
leaving out of their code. I don&#8217;t want to disclose too many details, but you
can see the code yourself on GitHub.</p>

<p>At first, I found one. So I tried to patch it. And I did, and it got accepted
into master. Awesome. But then, the more I read, the more bad things I found.
They&#8217;re going to need a complete overhaul to fix this. Go over every last
piece of code. And don&#8217;t even get me started on their encryption code.</p>

<p>But basically, please heed their own warning from <a href="http://www.joindiaspora.com/2010/09/15/developer-release.html">the announcement</a>:</p>

<blockquote><p>Feel free to try to get it running on your machines and use it, but we give
no guarantees. We know there are security holes and bugs, and your data is not
yet fully exportable. If you do find something, be sure to log it in our
bugtracker, and we would love screenshots and browser info.</p></blockquote>

<p>If you find one of the many, many nodes that people are publicly posting,
please don&#8217;t use your real passwords, or information.</p>

<p>And if you&#8217;re a developer, consider helping out. It&#8217;s going to be rough going:
the mailing list and issue trackers are full of people that have no idea what
they&#8217;re doing. Be prepared to wade through tons of crap. But they could
really, really use the help. I&#8217;ll be submitting another patch or two, but it
needs much, much more than I can give.</p>

<p>EDIT: Please check out <a href="http://blog.steveklabnik.com/this-is-why-new-media-hates-old-media">my follow up post</a>, where I talk about being
misquoted regarding this post.</p>

<p>EDIT 2: Patrick has a post up describing the exploits, now that there have
been some patches applied. If you&#8217;re a technically inclined individual, you
might be interested. You can find it on <a href="http://www.kalzumeus.com/2010/09/22/security-lessons-learned-from-the-diaspora-launch/">his blog</a>.</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/08/19/a-word-about-why-whyday-and-hackety-hack.html">A Word About Why, Whyday, and Hackety Hack</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-08-19T00:00:00-07:00" pubdate  data-updated="true" >Aug 19<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>Today is Whyday. A programmer&#8217;s holiday. Today is the day that we
don&#8217;t forget that programming isn&#8217;t all Agile and driven by behavior
and Serious Business. Inside each cubicle, the hacker spirit is trying
to burst free. Today, it will.</p>

<p>Today, I&#8217;m also releasing a prerelease version of Hackety Hack 1.0.
It&#8217;s been a long time coming. The announcement of Whyday got me
thinking about the past year of a world without _why, and the &#8216;your
domain is about to expire&#8217; notices got me thinking about how I&#8217;ve now
been the head of the Hackety Hack project for almost 12 months, too. I
don&#8217;t like thinking about this, because I almost let _why down.</p>

<p>I never met _why. I can&#8217;t really claim to know him, or know what his
intentions were, but I think about him a lot. &#8216;_why&#8217; the persona,
really embodies everything that I love about software. The world owes
_why a great debt, and I&#8217;d like to think that I&#8217;m doing what I can to
repay him.</p>

<p>At least, I am now. I don&#8217;t like to think about roughly 6 or 8 months
of the last year of Hackety Hack; I did an exceptionally poor job of
being a steward. Being alone, having no help, and having a bit of an
identity crisis is an excuse; you can decide if it&#8217;s a good or poor
one. But things have been looking up, and we&#8217;ve got some momentum, I
owe a great debt to Fela for helping make this summer happen.</p>

<p>I really do feel that the Little Coder still has a predicament, and
I&#8217;m almost to the point where they can find some solace. I still feel
that Hackety Hack could become an absolutely invauable project, I&#8217;ve
just got to keep going. I can, I will, and I am. But I wouldn&#8217;t be
able to if so many people didn&#8217;t care, say a nice world, or lend a
hand.</p>

<p>So thanks. And as ashbb would say, &#8220;Let&#8217;s all have fun with Hackety Hack!&#8221;</p>

<p>Happy Whyday.</p>

<p>EDIT: The release is now out. See the announcement <a href="http://hackety-hack.com/posts/happy_whyday">here</a>, and get it
<a href="http://hackety-hack.com/">here</a>.</p>

<p>Thanks!</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/07/24/a-blip-in-time.html">A Blip in Time</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-07-24T00:00:00-07:00" pubdate  data-updated="true" >Jul 24<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>Sometimes, insight comes from very unlikely places.</p>

<p>I&#8217;m keenly interested in the music industry, and how it will evolve, or
possibly die. I care deeply about music; it&#8217;s had a profound effect on my life
over the years. Even though the entire industry has been screaming that
they&#8217;re dying, I truly believe that music will never die. It&#8217;s bigger than
money. I&#8217;m not exactly sure about the details, even though I have some ideas.</p>

<p>In any case, I was reading about this the other day, and I came across <a href="http://sometimesright.com/2010/05/sir-mick-on-music-profits/">this
quote from Mick Jaggar</a>:</p>

<blockquote><p>But I have a take on that – people only made money out of records for a
very, very small time. When The Rolling Stones started out, we didn’t make any
money out of records because record companies wouldn’t pay you! They didn’t
pay anyone!</p>

<p>Then, there was a small period from 1970 to 1997, where people did get paid,
and they got paid very handsomely and everyone made money. But now that period
has gone.</p>

<p>So if you look at the history of recorded music from 1900 to now, there was
a 25 year period where artists did very well, but the rest of the time they
didn’t.</p></blockquote>

<p>An interesting bit of history, and an interesting perspective from someone who
has some skin in the game, to say the least. But it&#8217;s the last sentence of
that blog post that gives the true insight:</p>

<blockquote><p>Don’t stop at 1900, though. If you think of the entire history of the world,
the notion that you could make an outsized return on making music is a
complete aberration.</p></blockquote>

<p>When I first read this sentence, something clicked inside my head, and I had a
realization: does this apply to everything?</p>

<p>We always think that we&#8217;re moving forward. It&#8217;s called &#8216;progress&#8217; for a
reason. But it&#8217;s kind of obvious why we&#8217;d think this: we&#8217;re the ones living
it! Of course we&#8217;d do know wrong!</p>

<p>But what if we are?</p>

<p>What if we&#8217;re not progressing, but regressing? What if the latest and greatest
isn&#8217;t where things are going&#8230; it&#8217;s just a small blip in the graph?</p>

<p><img src="/images/blip.png" alt="" /></p>

<p>Maybe we&#8217;re actually going down the wrong path, building towards deflation,
and need to turn around and revise our position. Maybe we&#8217;ve misstepped. What
if we&#8217;re doing what we think is right, but it&#8217;s actually wrong? What if we&#8217;re
just on the upswing of some local minima?</p>

<p>I don&#8217;t necessarily mean that, for example, the music industry will cause the
total collapse of everything. But maybe it was a temporary peak. Things will
return back to some even level again, and over the grand sum of history, such
a small deviation will be forgotten.</p>

<p>Then I start to apply this line of reasoning to everything. How can we really
know if we&#8217;re doing better than yesterday?</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/07/17/what-to-know-before-debating-type-systems.html">What to Know Before Debating Type Systems</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-07-17T00:00:00-07:00" pubdate  data-updated="true" >Jul 17<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>Recently, it was brought up on Proggit that Chris Smith&#8217;s &#8220;What to Know Before
Debating Type Systems&#8221; was no longer online. This is a really great article,
and in an effort to make sure it survives, I&#8217;ve grabbed the <a href="http://web.archive.org/web/20080822101209/http://www.pphsg.org/cdsmith/types.html">archive.org
cache</a> and am &#8216;reprinting&#8217; it here. If you&#8217;re into programming languages,
read this and level up!</p>

<p>EDIT: Chris has placed it back online. You can find it <a href="http://cdsmith.wordpress.com/2011/01/09/an-old-article-i-wrote/">here</a>.</p>

<p>Without further ado, &#8220;What to Know Before Debating Type Systems&#8221;:</p>

<hr />

<h3>What To Know Before Debating Type Systems</h3>

<p>I would be willing to place a bet that most computer programmers have, on
multiple occasions, expressed an opinion about the desirability of certain
kinds of type systems in programming languages. Contrary to popular
conception, that&#8217;s a great thing! Programmers who care about their tools are
the same programmers who care about their work, so I hope the debate rages on.</p>

<p>There are a few common misconceptions, though, that confuse these discussions.
This article runs through those I&#8217;ve encountered that obscure the most
important parts of the debate. My goal is to build on a shared understanding
of some of the basic issues, and help people get to the interesting parts more
quickly.</p>

<h3>Classifying Type Systems</h3>

<p>Type systems are commonly classified by several words, of which the most
common are &#8220;static,&#8221; &#8220;dynamic,&#8221; &#8220;strong,&#8221; and &#8220;weak.&#8221; In this section, I
address the more common kinds of classification. Some are useful, and some are
not.</p>

<h4>Strong and Weak Typing</h4>

<p>Probably the most common way type systems are classified is &#8220;strong&#8221; or
&#8220;weak.&#8221; This is unfortunate, since these words have nearly no meaning at all.
It is, to a limited extent, possible to compare two languages with very
similar type systems, and designate one as having the strong<strong>er</strong> of those
two systems. Beyond that, the words mean nothing at all.</p>

<p>Therefore: I give the following general definitions for strong and weak
typing, at least when used as absolutes:</p>

<ul>
<li><strong>Strong typing:</strong> A type system that I like and feel comfortable with</li>
<li><strong>Weak typing:</strong> A type system that worries me, or makes me feel uncomfortable</li>
</ul>


<p>What about when the phrase is used in a more limited sense? Then strong
typing, depending on the speaker or author, may mean anything on the spectrum
from &#8220;static&#8221; to &#8220;sound,&#8221; both of which are defined below.</p>

<h4>Static and Dynamic Types</h4>

<p>This is very nearly the <em>only</em> common classification of type systems that has
real meaning. As a matter of fact, it&#8217;s significance is frequently under-
estimated. I realize that may sound ridiculous; but this theme will recur
throughout this article. Dynamic and static type systems are two <em>completely</em>
different things, whose goals happen to partially overlap.</p>

<p>A static type system is a mechanism by which a compiler examines source code
and assigns labels (called &#8220;types&#8221;) to pieces of the syntax, and then uses
them to infer something about the program&#8217;s behavior. A dynamic type system is
a mechanism by which a compiler generates code to keep track of the sort of
data (coincidentally, also called its &#8220;type&#8221;) used by the program. The use of
the same word &#8220;type&#8221; in each of these two systems is, of course, not really
entirely coincidental; yet it is best understood as having a sort of weak
historical significance. Great confusion results from trying to find a world
view in which &#8220;type&#8221; really means the same thing in both systems. It doesn&#8217;t.
The better way to approach the issue is to recognize that:</p>

<ul>
<li>Much of the time, programmers are trying to solve the same problem with static and dynamic types.</li>
<li>Nevertheless, static types are not limited to problems solved by dynamic types.</li>
<li>Nor are dynamic types limited to problems that can be solved with static types.</li>
<li>At their core, these two techniques are not the same thing at all.</li>
</ul>


<p>Observing the second of these four simple facts is a popular pass-time in some
circles. Consider <a href="http://web.archive.org/web/20080822101209/http://perl.plover.com/yak/typing/notes.html">this set of presentation notes</a>, with a rather
complicated &#8220;the type system found my infinite loop&#8221; comment. From a
theoretical perspective, preventing infinite loops is in a very deep sense the
most basic possible thing you can do with static types! The simply-typed
lambda calculus, on which all other type systems are based, proves that
programs terminate in a finite amount of time. Indeed, the more interesting
question is how to usefully extend the type system to be able to describe
programs that don&#8217;t terminate! Finding infinite loops, though, is not in the
class of things most people associate with &#8220;types,&#8221; so it&#8217;s surprising. It is,
indeed, provably impossible with dynamic types (that&#8217;s called the halting
problem; you&#8217;ve probably heard of it!). But it&#8217;s nothing special for static
types. Why? Because they are an entirely different thing from dynamic types.</p>

<p>The dichotomy between static and dynamic types is somewhat misleading. Most
languages, even when they claim to be dynamically typed, have some static
typing features. As far as I&#8217;m aware, _all_languages have some dynamic typing
features. However, most languages can be characterized as choosing one or the
other. Why? Because of the first of the four facts listed above: many of the
problems solved by these features overlap, so building in strong versions of
both provides little benefit, and significant cost.</p>

<h4>Other Distinctions</h4>

<p>There are many other ways to classify type systems. These are less common, but
here are some of the more interesting ones:</p>

<ul>
<li><strong>Sound types.</strong> A sound type system is one that provides some kind of guarantee. It is a well-defined concept relating to static type systems, and has proof techniques and all those bells and whistles. Many modern type systems are sound; but older languages like C often do not have sound type systems by design; their type systems are just designed to give warnings for common errors. The concept of a sound type system can be imperfectly generalized to dynamic type systems as well, but the exact definition there may vary with usage.</li>
<li><strong>Explicit/Implicit Types.</strong> When these terms are used, they refer to the extent to which a compiler will reason about the static types of parts of a program. All programming languages have some form of reasoning about types. Some have more than others. ML and Haskell have implicit types, in that no (or very few, depending on the language and extensions in use) type declarations are needed. Java and Ada have very explicit types, and one is constantly declaring the types of things. All of the above have (relatively, compared to C and C++, for example) strong static type systems.</li>
<li><strong>The Lambda Cube.</strong> Various distinctions between static type systems are summarized with an abstraction called the &#8220;lambda cube.&#8221; Its definition is beyond the scope of this article, but it basically looks at whether the system provides certain features: parametric types, dependent types, or type operators. Look <a href="http://web.archive.org/web/20080822101209/http://citeseer.ist.psu.edu/barendregt92lambda.html">here</a> for more information.</li>
<li><strong>Structural/Nominal Types.</strong> This distinction is generally applied to static types with subtyping. Structural typing means a type is assumed whenever it is possible to validly assume it. For example, a record with fields called x, y, and z might be automatically considered a subtype of one with fields x and y. With nominal typing, there would be no such assumed relationship unless it were declared somewhere.</li>
<li><strong>Duck Typing.</strong> This is a word that&#8217;s become popular recently. It refers to the dynamic type analogue of structural typing. It means that rather than checking a tag to see whether a value has the correct general type to be used in some way, the runtime system merely checks that it supports all of the operations performed on it. Those operations may be implemented differently by different types.</li>
</ul>


<p>This is but a small sample, but this section is too long already.</p>

<h3>Fallacies About Static and Dynamic Types</h3>

<p>Many programmers approach the question of whether they prefer static or
dynamic types by comparing some languages they know that use both techniques.
This is a reasonable approach to most questions of preference. The problem, in
this case, is that most programmers have limited experience, and haven&#8217;t tried
a lot of languages. For context, here, six or seven doesn&#8217;t count as &#8220;a lot.&#8221;
On top of that, it requires more than a cursory glance to really see the
benefit of these two very different styles of programming. Two interesting
consequences of this are:</p>

<ul>
<li>Many programmers have used very poor statically typed languages.</li>
<li>Many programmers have used dynamically typed languages very poorly.</li>
</ul>


<p>This section, then, brings up some of the consequences of this limited
experience: things many people assume about static or dynamic typing that just
ain&#8217;t so.</p>

<h4>Fallacy: Static types imply type declarations</h4>

<p>The thing most obvious about the type systems of Java, C, C++, Pascal, and
many other widely-used &#8220;industry&#8221; languages is not that they are statically
typed, but that they are explicitly typed. In other words, they require lots
of type declarations. (In the world of less explicitly typed languages, where
these declarations are optional, they are often called &#8220;type annotations&#8221;
instead. You may find me using that word.) This gets on a lot of people&#8217;s
nerves, and programmers often turn away from statically typed languages for
this reason.</p>

<p>This has nothing to do with static types. The first statically typed languages
were explicitly typed by necessity. However, type inference algorithms -
techniques for looking at source code with no type declarations at all, and
deciding what the types of its variables are - have existed for many years
now. The ML language, which uses it, is among the older languages around
today. Haskell, which improves on it, is now about 15 years old. Even C# is
now adopting the idea, which will raise a lot of eyebrows (and undoubtedly
give rise to claims of its being &#8220;weakly typed&#8221; &#8211; see definition above). If
one does not like type declarations, one is better off describing that
accurately as not liking explicit types, rather than static types.</p>

<p>(This is not to say that type declarations are always bad; but in my
experience, there are few situations in which I&#8217;ve wished to see them
required. Type inference is generally a big win.)</p>

<h4>Fallacy: Dynamically typed languages are weakly typed</h4>

<p>The statement made at the beginning of this thread was that many programmers
have used dynamically typed languages poorly. In particular, a lot of
programmers coming from C often treat dynamically typed languages in a manner
similar to what made sense for C prior to ANSI function prototypes.
Specifically, this means adding lots of comments, long variable names, and so
forth to obssessively track the &#8220;type&#8221; information of variables and functions.</p>

<p>Doing this prevents a programmer from realizing the benefits of dynamic
typing. It&#8217;s like buying a new car, but refusing to drive any faster than a
bicycle. The car is horrible; you can&#8217;t get up the mountain trails, and it
requires gasoline on top of everything else. Indeed, a car is a pretty lousy
excuse for a bicycle! Similarly, dynamically typed languages are pretty lousy
excuses for statically typed languages.</p>

<p>The trick is to compare dynamically typed languages when used in ways that fit
in with their design and goals. Dynamically typed languages have all sorts of
mechanisms to fail immediately and clearly if there is a runtime error, with
diagnostics that show you exactly how it happened. If you program with the
same level of paranoia appropriate to C - where a simple bug may cause a day
of debugging - you will find that it&#8217;s tough, and you won&#8217;t be actually using
your tools.</p>

<p>(As a side comment, and certainly a more controversial one, the converse is
equally true; it doesn&#8217;t make sense to do the same kinds of exhaustive unit
testing in Haskell as you&#8217;d do in Ruby or Smalltalk. It&#8217;s a waste of time.
It&#8217;s interesting to note that the whole TDD movement comes from people who are
working in dynamically typed languages&#8230; I&#8217;m not saying that unit testing is
a bad idea with static types; only that it&#8217;s entirely appropriate to scale it
back a little.)</p>

<h4>Fallacy: Static types imply upfront design or waterfall methods</h4>

<p>Some statically typed languages are also designed to enforce someone&#8217;s idea of
a good development process. Specifically, they often require or encourage that
you specify the whole interface to something in one place, and then go write
the code. This can be annoying if one is writing code that evolves over time
or trying out ideas. It sometimes means changing things in several different
places in order to make one tweak. The worst form of this I&#8217;m aware of (though
done mainly for pragmatic reasons rather than ideological ones) is C and C++
header files. Pascal has similar aims, and requires that all variables for a
procedure or function be declared in one section at the top. Though few other
languages enforce this separation in quite the same way or make it so hard to
avoid, many do encourage it.</p>

<p>It is absolutely true that these language restrictions can get in the way of
software development practices that are rapidly gaining acceptance, including
agile methodologies. It&#8217;s also true that they have nothing to do with static
typing. There is nothing in the core ideas of static type systems that has
anything to do with separating interface from implementation, declaring all
variables in advance, or any of these other organizational restrictions. They
are sometimes carry-overs from times when it was considered normal for
programmers to cater to the needs of their compilers. They are sometimes
ideologically based decisions. They are not static types.</p>

<p>If one doesn&#8217;t want a language deciding how they should go about designing
their code, it would be clearer to say so. Expressing this as a dislike for
static typing confuses the issue.</p>

<p>This fallacy is often stated in different terms: &#8220;I like to do exploratory
programming&#8221; is the popular phrase. The idea is that since everyone knows
statically typed languages make you do everything up front, they aren&#8217;t as
good for trying out some code and seeing what it&#8217;s like. Common tools for
exploratory programming include the REPL (read-eval-print loop), which is
basically an interpreter that accepts statements in the language a line at a
time, evaluates them, and tells you the result. These tools are quite useful,
and they exist for many languages, both statically and dynamically typed. They
don&#8217;t exist (or at least are not widely used) for Java, C, or C++, which
perpetuates the unfortunate myth that they only work in dynamically typed
languages. There may be advantages for dynamic typing in exploratory
programming (in fact, there certainly are <em>some</em> advantages, anyway), but it&#8217;s
up to someone to explain what they are, rather than just to imply the lack of
appropriate tools or language organization.</p>

<h4>Fallacy: Dynamically typed languages provide no way to find bugs</h4>

<p>A common argument leveled at dynamically typed languages is that failures will
occur for the customer, rather than the developer. The problem with this
argument is that it very rarely occurs in reality, so it&#8217;s not very
convincing. Programs written in dynamically typed languages don&#8217;t have far
higher defect rates than programs written in languages like C++ and Java.</p>

<p>One can debate the reasons for this, and there are good arguments to be had
there. One reason is that the average skill level of programmers who know Ruby
is higher than those who know Java, for example. One reason is that C++ and
Java have relatively poor static type systems. Another reason, though, is
testing. As mentioned in the aside above, the whole unit testing movement
basically came out of dynamically typed languages. It has some definite
disadvantages over the guarantees provided by static types, but it also has
some advantages; static type systems can&#8217;t check nearly as many properties of
code as testing can. Ignoring this fact when talking to someone who really
knows Ruby will basically get you ignored in turn.</p>

<h4>Fallacy: Static types imply longer code</h4>

<p>This fallacy is closely associated with the one above about type declarations.
Type declarations are the reason many people associated static types with a
lot of code. However, there&#8217;s another side to this. Static types often allow
one to write much more concise code!</p>

<p>This may seem like a surprising claim, but there&#8217;s a good reason. Types carry
information, and that information can be used to resolve things later on and
prevent programmers from needing to write duplicate code. This doesn&#8217;t show up
often in simple examples, but a really excellent case is found in the Haskell
standard library&#8217;s <code>Data.Map</code> module. This module implements a balanced binary
search tree, and it contains a function whose type signature looks like this:</p>

<blockquote><p>lookup :: (Monad m, Ord k) => k -> Map k a -> m a</p></blockquote>

<p>This is a magical function. It says that I can look something up in a <code>Map</code>
and get back the result. Simple enough, but here&#8217;s the trick: what do I do if
the result isn&#8217;t there? Common answers might include returning a special
&#8220;nothing&#8221; value, or aborting the current computation and going to an error
handler, or even terminating the whole program. The function above does any of
the above! Here&#8217;s how I compare the result against a special nothing value:</p>

<blockquote><p>case (lookup bobBarker employees) of Nothing -> hire bobBarker Just salary
-> pay bobBarker salary</p></blockquote>

<p>How does Haskell know that I want to choose the option of getting back
<code>Nothing</code> when the value doesn&#8217;t exist, rather than raising some other kind of
error? It&#8217;s because I wrote code afterward to compare the result against
<code>Nothing</code>! If I had written code that didn&#8217;t immediately handle the problem
but was called from somewhere that handled errors three levels up the stack,
then <code>lookup</code> would have failed that way instead, and I&#8217;d be able to write
seven or eight consecutive lookup statements and compute something with the
results without having to check for <code>Nothing</code> all the time. This completely
dodges the very serious &#8220;exception versus return value&#8221; debate in handling
failures in many other languages. This debate has no answer. Return values are
great if you want to check them now; exceptions are great if you want to
handle them several levels up. This code simply goes along with whatever you
write the code to do.</p>

<p>The details of this example are specific to Haskell, but similar examples can
be constructed in many statically typed languages. There is no evidence that
code in ML or Haskell is any longer than equivalent code in Python or Ruby.
This is a good thing to remember before stating, as if it were obviously true,
that statically typed languages require more code. It&#8217;s not obvious, and I
doubt if it&#8217;s true.</p>

<h3>Benefits of Static Types</h3>

<p>My experience is that the biggest problems in the static/dynamic typing debate
occur in failing to understand the issues and potential of static types. The
next two sections, then, are devoted to explaining this position in detail.
This section works upward from the pragmatic perspective, while the next
develops it into its full form.</p>

<p>There are a number of commonly cited advantages for static typing. I am going
to list them in order from <em>least</em> to <em>most</em> significant. (This helps the
general structure of working up to the important stuff.)</p>

<h4>Performance</h4>

<p>Performance is the gigantic red herring of all type system debates. The
knowledge of the compiler in a statically typed language can be used in a
number of ways, and improving performance is one of them. It&#8217;s one of the
least important, though, and one of the least interesting.</p>

<p>For most computing environments, performance is the problem of two decades
ago. Last decade&#8217;s problem was already different, and this decades problems
are at least 20 years advanced beyond performance being the main driver of
technology decisions. We have new problems, and performance is not the place
to waste time.</p>

<p>(On the other hand, there are a few environments where performance still
matters. Languages in use there are rarely dynamically typed, but I&#8217;m not
interested enough in them to care much. If you do, maybe this is your corner
of the type system debate.)</p>

<h4>Documentation</h4>

<p>If, indeed, performance is irrelevant, what does one look to next? One answer
is documentation. Documentation is an important aspect of software, and static
typing can help.</p>

<p>Why? Because documentation isn&#8217;t just about comments. It&#8217;s about everything
that helps people understand software. Static type systems build ideas that
help explain a system and what it does. The capture information about the
inputs and outputs of various functions and modules. This is exactly the set
of information needed in documentation. Clearly, if all of this information is
written in comments, there is a pretty good chance it will eventually become
out of date. If this information is written in identifier names, it will be
nearly impossible to fit it all in. It turns out that type information is a
very nice place to keep this information.</p>

<p>That&#8217;s the boring view. As everyone knows, though, it&#8217;s better to have self-
documenting code than code that needs a lot of comments (even if it has
them!). Conveniently enough, most languages with interesting static type
systems have type inference, which is directly analogous to self-documenting
code. Information about the correct way to use a piece of code is extracted
from the code itself (i.e., it&#8217;s self-documenting), but then verified and
presented in a convenient format. It&#8217;s documentation that doesn&#8217;t need to be
maintained or even written, but is available on demand even without reading
the source code.</p>

<h4>Tools and Analysis</h4>

<p>Things get way more interesting than documentation, though. Documentation is
writing for human beings, who are actually pretty good at understanding code
anyway. It&#8217;s great that the static type system can help, but it doesn&#8217;t do
anything fundamentally new.</p>

<p>Fundamentally new things happen when type systems help computer programs to
understand code. Perhaps I need to explain myself here. After all, a wise man
(Martin Fowler, IIRC) one said:</p>

<blockquote><p>&#8220;Any fool can write code that a computer can understand. Good programmers
write code that humans can understand.&#8221;</p></blockquote>

<p>I don&#8217;t disagree with Martin Fowler, but we have different definitions of
<em>understand</em> in mind. Getting a computer to follow code step by step is easy.
Getting a computer to analyze it and answer more complex questions about it is
a different thing entirely, and it is very hard.</p>

<p>We often want our development tools to understand code. This is a big deal.
I&#8217;ll turn back to Martin Fowler, who <a href="http://web.archive.org/web/20080822101209/http://www.martinfowler.com/bliki/DynamicTyping.html">points this out as well</a>.</p>

<h4>Correctness</h4>

<p>Ultimately, though, the justification for static typing has to come back to
writing correct code. Correctness, of course, is just the program doing &#8220;what
you want.&#8221;</p>

<p>This is a really tough problem; perhaps the toughest of all. The theory of
computation has a result called Rice&#8217;s Theorem, which essentially says this:
Given an arbitrary program written in a general purpose programming language,
it is impossible to write a computer program that determines anything about
the program&#8217;s output. If I&#8217;m teaching an intro to programming class and assign
my students to write &#8220;hello world&#8221;, I can&#8217;t program a grader to determine if
they did so or not. There will be some programs for which the answer is easy;
if the program never makes any I/O calls, then the answer is no. If the
program consists of a single print statement, it&#8217;s easy to check if the answer
is yes. However, there will be some complicated programs for which my grader
can never figure out the answer. (A minor but important technical detail: one
can&#8217;t run the program and wait for it to finish, because the program might
never finish!) This is true of any statement about programs, including some
more interesting ones like &#8220;does this program ever finish?&#8221; or &#8220;does this
program violate my security rules?&#8221;</p>

<p>Given that we can&#8217;t actually check the correctness of a program, there are two
approaches that help us make approximations:</p>

<ul>
<li><strong>Testing:</strong> establishes upper bounds on correctness</li>
<li><strong>Proof:</strong> establishes lower bounds on correctness</li>
</ul>


<p>Of course, we care far more about lower bounds than upper bounds. The problem
with proofs, though, is the same as the problem with documentation. Proving
correctness is easy only somewhat insanely difficult when you have a static
body of code to prove things about. When the code is being maintained by three
programmers and changing seven times per day, maintaining the correctness
proofs falls behind. Static typing here plays exactly the same role as it does
with documentation. If (and this is a big if) you can get your proofs of
correctness to follow a certain form that can be reproduced by machine, the
computer itself can be the prover, and let you know if the change you just
made breaks the proof of correctness. The &#8220;certain form&#8221; is called structural
induction (over the syntax of the code), and the prover is called a type
checker.</p>

<p>An important point here is that static typing does not preclude proving
correctness in the traditional way, nor testing the program. It is a technique
to handle those cases in which testing might be guaranteed to succeed so they
don&#8217;t need testing; and similarly, to provide a basis from which the effort of
manual proof can be saved for those truly challenging areas in which it is
necessary.</p>

<h4>Dynamic Typing Returns</h4>

<p>Certainly dynamic typing has answers to this. Dynamically typed languages can
sometimes perform rather well (see Dylan), sometimes have great tools (see
Smalltalk), and I&#8217;m sure they occasionally have good documentation as well,
though the hunt for an example is too much for me right now. These are not
knock-down arguments for static typing, but they are worth being aware of.</p>

<p>The correctness case is particularly enlightening. Just as static types
strengthened our proofs of correctness by making them easier and automatic,
dynamic typing improves testing by making it easier and more effective. It
simply makes the code fail more spectacularly. I find it amusing when novice
programmers believe their main job is preventing programs from crashing. I
imagine this spectacular failure argument wouldn&#8217;t be so appealing to such a
programmer. More experienced programmers realize that correct code is great,
code that crashes could use improvement, but incorrect code that doesn&#8217;t crash
is a horrible nightmare.</p>

<p>It is through testing, then, that dynamically typed languages establish
correctness. Recall that testing establishes only upper bounds on correctness.
(Dijkstra said it best: &#8220;Program testing can be used to show the presence of
bugs, but never to show their absence.&#8221;) The hope is that if one tries hard
enough and still fails to show the presence of bugs, then their absence
becomes more likely. If one can&#8217;t seem to prove any better upper bound, then
perhaps the correctness really is 100%. Indeed, there is probably at some
correlation in that direction.</p>

<h3>What is a Type?</h3>

<p>This is as good a point as any to step back and ask the fundamental question:
what is a type? I&#8217;ve already mentioned that I think there are two answers. One
answer is for static types, and the other is for dynamic types. I am
considering the question for static types.</p>

<p>It is dangerous to answer this question too quickly. It is dangerous because
we risk excluding some things as types, and missing their &#8220;type&#8221; nature
because we never look for it. Indeed, the definition of a type that I will
eventually give is extremely broad.</p>

<h4>Problems with Common Definitions</h4>

<p>One common saying, quoted often in an attempt to reconcile static and dynamic
typing, goes something like this: Statically typed languages assign types to
variables, while dynamically typed languages assign types to values. Of
course, this doesn&#8217;t actually define types, but it is already clearly and
obviously wrong. One could fix it, to some extent, by saying &#8220;statically typed
languages assign types to expressions, &#8230;&#8221; Even so, the implication that
these types are fundamentally the same thing as the dynamic version is quite
misleading.</p>

<p>What is a type, then? When a typical programmer is asked that question, they
may have several answers. Perhaps a type is just a set of possible values.
Perhaps it is a set of operations (a very structural-type-ish view, to be
sure). There could be arguments in favor of each of these. One might make a
list: integers, real numbers, dates, times, and strings, and so on.
Ultimately, though, the problem is that these are all symptoms rather than
definitions. Why is a type a set of values? It&#8217;s because one of the things we
want to prove about our program is that it doesn&#8217;t calculate the square roots
of a string. Why is a type a set of operations? It&#8217;s because one of the things
we want to know is whether our program attempts to perform an impossible
operation.</p>

<p>Let&#8217;s take a look at another thing we often want to know: does our web
application stick data from the client into SQL queries without escaping
special characters first? If this is what we want to know, then these becomes
types. <a href="http://web.archive.org/web/20080822101209/http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem">This article by Tom Moertel</a> builds this on top of Haskell&#8217;s type
system. So far, it looks like a valid definition of &#8220;type&#8221; is as follows:
something we want to know.</p>

<h4>A Type System</h4>

<p>Clearly that&#8217;s not a satisfactory definition of a type. There are plenty of
things we want to know that types can&#8217;t tell us. We want to know whether our
program is correct, but I already said that types provide conservative lower
bounds on correctness, and don&#8217;t eliminate the need for testing or manual
proof. What makes a type a type, then? The other missing component is that a
type is part of a type system.</p>

<p>Benjamin Pierce&#8217;s book <a href="http://web.archive.org/web/20080822101209/http://www.amazon.com/dp/0262162091">Types and Programming Languages</a> is far ans away
the best place to read up on the nitty gritty details of static type systems,
at least if you are academically inclined. I&#8217;ll quote his definition.</p>

<blockquote><p><em>A type system is a tractable syntactic method for proving the absence of
certain program behaviors by classifying phrases according to the kinds of
values they compute.</em></p></blockquote>

<p>This is a complex definition, but the key ideas are as follows:</p>

<ul>
<li><em>syntactic method .. by classifying phrases</em>: A type system is necessarily tied to the syntax of the language. It is a set of rules for working bottom up from small to large phrases of the language until you reach the result.</li>
<li><em>proving the absence of certain program behaviors</em>: This is the goal. There is no list of &#8220;certain&#8221; behaviors, though. The word just means that for any specific type system, there will be a list of things that it proves. What it proves is left wide open. (Later on in the text: &#8220;&#8230; each type system comes with a definition of the behaviors it aims to prevent.&#8221;)</li>
<li><em>tractable</em>: This just means that the type system finishes in a reasonable period of time. Without wanting to put words in anyone&#8217;s mouth, I think it&#8217;s safe to say most people would agree that it&#8217;s a mistake to include this in the definition of a type system. Some languages even have undecidable type systems. Nevertheless, it is certainly a common goal; one doesn&#8217;t expect the compiler to take two years to type-check a program, even if the program will run for two years.</li>
</ul>


<p>The remainder of the definition is mainly unimportant. The &#8220;kinds of values
they compute&#8221; is basically meaningless unless we know what kinds we might
choose from, and the answer is any kind at all.</p>

<p>An example looks something like that. Given the expression <code>5 + 3</code>, a type
checker may look at 5 and infer that it&#8217;s an integer. It may look at 3 and
infer it&#8217;s an integer. It may then look at the + operator, and know that when
+ is applied to two integers, the result is an integer. Thus it&#8217;s proven the
absence of program behaviors (such as adding an integer to a string) by
working up from the basic elements of program syntax.</p>

<h4>Examples of Unusual Type Systems</h4>

<p>That was a pretty boring example, and one that plays right into a trap:
thinking of &#8220;type&#8221; as meaning the same thing it does in a dynamic type system.
Here are some more interesting problems being solved with static types.</p>

<ul>
<li><a href="http://web.archive.org/web/20080822101209/http://wiki.di.uminho.pt/twiki/pub/Personal/Xana/WebHome/report.pdf">http://wiki.di.uminho.pt/twiki/pub/Personal/Xana/WebHome/report.pdf</a>. Uses types to ensure that the correct kinds of data are gotten out of a relational database. Via the type system, the compiler ends up understanding how to work with concepts like functional dependencies and normal forms, and can statically prove levels of normalization.</li>
<li><a href="http://web.archive.org/web/20080822101209/http://www.cs.bu.edu/~hwxi/academic/papers/pldi98.pdf">http://www.cs.bu.edu/~hwxi/academic/papers/pldi98.pdf</a>. Uses an extension to ML&#8217;s type system to prove that arrays are never accessed out of bounds. This is an unusually hard problem to solve without making the languages that solve it unusable, but it&#8217;s a popular one to work on.</li>
<li><a href="http://web.archive.org/web/20080822101209/http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf">http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf</a>. This is great. This example uses Haskell&#8217;s type system to let someone define a security policy for a Haskell program, in Haskell, and then proves that the program properly implements that security. If a programmer gets security wrong, the compiler will complain rather than opening up a potential security bug in the system.</li>
<li><a href="http://web.archive.org/web/20080822101209/http://www.brics.dk/RS/01/16/BRICS-RS-01-16.pdf">http://www.brics.dk/RS/01/16/BRICS-RS-01-16.pdf</a>. Just in case you thought type systems only solved easy problems, this bit of Haskell gets the type system to prove two central theorems about the simply typed lambda calculus, a branch of computation theory!</li>
</ul>


<p>The point of these examples is to point out that type systems can solve all
sorts of programming problems. For each of these type systems, concepts of
types are created that represent the ideas needed to accomplish this
particular task with the type system. Some problems solved by static type
systems look nothing like the intuitive idea of a type. A buggy security check
isn&#8217;t normally considered a type error, but only because not many people use
languages with type systems that solve that problem.</p>

<p>To reiterate the point above, it&#8217;s important to understand how limiting it is
to insist, as many people do, that the dynamic typing definition of a &#8220;type&#8221;
is applied to static typing as well. One would miss the chance to solve
several real-world problems mentioned above.</p>

<h4>The True Meaning of Type</h4>

<p>So what is a type? The only true definition is this: a type is a label used by
a type system to prove some property of the program&#8217;s behavior. If the type
checker can assign types to the whole program, then it succeeds in its proof;
otherwise it fails and points out why it failed. This is a definition, then,
but it doesn&#8217;t tell us anything of fundamental importance. Some further
exploration leads us to insight about the fundamental trade-offs involved in
using a static type checker.</p>

<p>If you were looking at things the right way, your ears may have perked up a
few sections back, when I said that Rice&#8217;s Theorem says we can&#8217;t determine
anything about the output of a program. Static type systems prove properties
of code, but it almost appears that Rice&#8217;s Theorem means we can&#8217;t prove
anything of interest with a computer. If true, that would be an ironclad
argument against static type systems. Of course, it&#8217;s not true. However, it is
very nearly true. What Rice&#8217;s Theorem says is that we can&#8217;t determine
anything. (Often the word &#8220;decide&#8221; is used; they mean the same thing here.) It
didn&#8217;t say we can&#8217;t prove anything. It&#8217;s an important distinction!</p>

<p>What this distinction means is that a static type system is a conservative
estimate. If it accepts a program, then we know the program has the properties
proven by that type checker. If it fails&#8230; then we don&#8217;t know anything.
Possibly the program doesn&#8217;t have that property, or possibly the type checker
just doesn&#8217;t know how to prove it. Furthermore, there is an ironclad
mathematical proof that a type checker of any interest at all is <em>always</em>
conservative. Building a type checker that doesn&#8217;t reject any correct programs
isn&#8217;t just difficult; it&#8217;s impossible.</p>

<p>That, then, is the trade-off. We get assurance that the program is correct (in
the properties checked by this type checker), but in turn we must reject some
interesting programs. To continue the pattern, this is the diametric opposite
of testing. With testing, we are assured that we&#8217;ll never fail a correct
program. The trade-off is that for any program with an infinite number of
possible inputs (in other words, any interesting program), a test suite may
still accept programs that are not correct - even in just those properties
that are tested.</p>

<h3>Framing the Interesting Debate</h3>

<p>That last paragraph summarizes the interesting part of the debate between
static and dynamic typing. The battleground on which this is fought out is
framed by eight questions, four for each side:</p>

<ol>
<li>For what interesting properties of programs can we build static type systems?</li>
<li>How close can we bring those type systems to the unattainable ideal of never rejecting a correct program?</li>
<li>How easy can it be made to program in a language with such a static type system?</li>
<li>What is the cost associated with accidentally rejecting a correct computer program?</li>
<li>For what interesting properties of programs can we build test suites via dynamic typing?</li>
<li>How close can we bring those test suites to the unattainable ideal of never accepting a broken program?</li>
<li>How easy can it be made to write and execute test suites for programs?</li>
<li>What is the cost associated with accidentally accepting an incorrect computer program?</li>
</ol>


<p>If you knew the answer to those eight questions, you could tell us all, once
and for all, where and how we ought to use static and dynamic typing for our
programming tasks.</p>
</div>
  
  


  </article>


  <article>
    
  <header>
    
      <h1 class="entry-title"><a href="/2010/06/30/case-study-in-being-excellent-divvy.html">Case Study in Being Excellent: Divvy</a></h1>
    
    
      <p class="meta">





  



<time datetime="2010-06-30T00:00:00-07:00" pubdate  data-updated="true" >Jun 30<span>th</span>, 2010</time></p>
    
  </header>


  <div class="entry-content"><p>The other day I wrote a post about <a href="http://blog.steveklabnik.com/being-excellent-to-each-other">being excellent to each other</a>.
Today, I&#8217;ve got a great example of that for you: Divvy.</p>

<p>What would you do if you received an email like this?</p>

<p><img src="/images/divvy1.png" alt="" /></p>

<p>Here&#8217;s what happened:</p>

<p><img src="/images/divvy2.png" alt="" /></p>

<p>Here&#8217;s a <a href="http://www.reddit.com/r/programming/comments/ckcbr/mizage_a_small_development_company_that_made/">link to the thread</a>. Check out some of these comments:</p>

<p><img src="/images/divvy3.png" alt="" /></p>

<p>&#8230; okay, maybe that last one is a bit much. But still, they&#8217;ve obviously been
repaid many times over for something that <em>didn&#8217;t even cost them money</em>. This
<a href="http://news.ycombinator.com/item?id=1473770">comment on HN</a> really says it all:</p>

<p><img src="/images/divvy4.png" alt="" /></p>

<p>If you&#8217;d also like to support a company for being awesome, here&#8217;s a link
to <a href="http://www.mizage.com/divvy/">Divvy</a>.</p>

<p>EDIT: They&#8217;ve posted the sales afterward on Reddit <a href="http://www.reddit.com/r/programming/comments/cmmfg/hey_reddit_a_week_ago_someone_posted_about_divvy/">here</a>.</p>
</div>
  
  


  </article>

<nav role="pagination">
  <div>
    
      <a class="prev" href="/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/page/2/">Newer &rarr;</a>
    
  </div>
</nav>

</div>
<aside role=sidebar>
  
    <aside>
<img src='http://en.gravatar.com/userimage/5335489/ee56a7574df33ed8748160494c930b98.jpg?size=190' />
<h4>Hi there, I&#8217;m Steve.</h4>
<p>
I write both code and prose. Here&#8217;s some of my thoughts about software,
literature, art and code, with some politics thrown in on occasion.
You might also enjoy <a href="http://steveklabnik.com/">my website</a>.
</p>
</aside>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/2011/09/26/im-deleting-my-facebook-tonight.html">I&#8217;m Deleting My Facebook Tonight.</a>
      </li>
    
      <li class="post">
        <a href="/2011/09/23/more-rstat-dot-us-refactoring.html">More rstat.us Refactoring</a>
      </li>
    
      <li class="post">
        <a href="/2011/09/22/extracting-domain-models-a-practical-example.html">Extracting Domain Models: A Practical Example</a>
      </li>
    
      <li class="post">
        <a href="/2011/09/09/better-ruby-presenters.html">Better Ruby Presenters</a>
      </li>
    
      <li class="post">
        <a href="/2011/09/06/the-secret-to-rails-oo-design.html">The Secret to Rails OO Design</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/steveklabnik">@steveklabnik</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'steveklabnik',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("steveklabnik", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/steveklabnik" class="twitter-follow-button" data-width="208px" data-show-count="false">Follow @steveklabnik</a>
  
</section>




  
</aside>

    </div>
  </div>
  <footer><p>
  Copyright &copy; 2011 - Steve Klabnik -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-10289851-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


  
  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>


  
  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>


</body>
</html>
